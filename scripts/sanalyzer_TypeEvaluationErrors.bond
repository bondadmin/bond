namespace OuterSpace
{
	namespace InnerSpace
	{
		const int Number = 1;
	}
}

struct DummyStruct
{
	int x;
	int DummyFunction(float arg);
};

int [2]* FunnyReturnType();

void DummyFunction(const DummyStruct ds, void *ptr)
{
	int[2] array1;
	int[2] array2;
	int *ptr1 = array1;
	int *ptr2 = array2;
	int i1 = 1;
	int i2 = 2;
	float f1 = 1.0;
	float f2 = 2.0;
	bool b1 = true;
	bool b2 = false;

	// Invalid statements.
	array1 = array2;
	*FunnyReturnType() = array2;
	f1 = ds;
	f1 <<= i1;
	i2 %= f2;
	ptr2 = ptr1 + f1;
	1 + FunnyReturnType;
	i1 /= ptr1;
	b1 = b2 || ds;
	i1 = true & 1.0;
	b1 = false < f1;
	i1 = -b1;
	b1 = !f1;
	*ds;
	~f1;
	++ds;
	ds->x;
	ptr1->x;
	ds.y;
	array1[f1];
	f1[0];
	ds.x();
	ptr1 = cast<int *>(ds);
	1 + DummyStruct;
	1 + SymbolToBeDefined;
	true ? 1 : false;
	&6 = ptr1;
	*ptr;

	const int uninitialized;
	uninitialized = 6;

	int SymbolToBeDefined = 0;

	{
		int SymbolThatWillGoOutOfScope = 0;
		i1 = SymbolThatWillGoOutOfScope;
	}

	i1 = SymbolThatWillGoOutOfScope;
	ds.DummyFunction(f1, f2);
	ds.DummyFunction(ds);

	// Valid statements.
	(*FunnyReturnType())[0] = 1;
	i1 = 1 << 2;
	i1 <<= i2;
	ptr2 = ptr1 + i1;
	f2 = i1 + f1;
	i1 /= i2;
	b1 = b2 || false;
	i1 = 1 & 2;
	i2 = 1 | 2;
	b1 = 1 < f1;
	i1 = +-i2;
	i1 = *ptr1;
	ptr2 = ++ptr1;
	ptr2 = ptr1--;
	ds.x = 3;
	i1 = ds.DummyFunction(f1);
	array1[0] = i1;
	ptr1[0] = 2;
	ptr1 = cast<int *>(&ds);
	i1 = OuterSpace::InnerSpace::Number;
}
